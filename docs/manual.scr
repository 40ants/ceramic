@begin(section)
@title(Introduction)

Ceramic is a library for creating desktop applications with web technologies and
Common Lisp. It allows you to ship a native application that runs a Lisp web
server, and displays browser windows to use that server, effectively turning a
web application into a desktop app.

Ceramic is inspired by @link[uri="http://nwjs.io/"](NW.js) and uses
@link[uri="http://electron.atom.io/"](Electron).

@begin(section)
@title(Features)

@begin(deflist)
@term(Multi-platform)
@def(Runs on Linux, Windows and Mac.)

@term(No JavaScript)
@def(Respects your good taste and mental health.)
@end(deflist)

@end(section)

@begin(section)
@title(Examples)

@begin(section)
@title(@link[uri="https://github.com/ceramic/marked/"](Marked))

A simple Markdown editor and previewer.

@end(section)

@end(section)

@end(section)

@begin(section)
@title(Tutorial)

@begin(section)
@title(Installation)

Until Ceramic is available from Quicklisp, you have to clone it to your
Quicklisp @c(local-projects) directory. Assuming your Quicklisp directory is
@c(~/quicklisp):

@code[lang=shell](git clone https://github.com/ceramic/ceramic.git ~/quicklisp/local-projects)

Then, either restart Lisp or run @c((ql:register-local-projects)).

@end(section)

@begin(section)
@title(Getting Started)

First, we need to load Ceramic. We do this with Quicklisp:

@code[lang=lisp](CL-USER> (ql:quickload :ceramic))

Ceramic needs to download some things to run, so let's do that:

@code[lang=lisp](CL-USER> (ceramic.setup:setup))

Now we're all set up. Let's start creating some browser windows. Run the
following code:

@begin[lang=lisp](code)
;; Tell Ceramic we're going to be prototyping
(ceramic:interactive)

;; Create a browser window
(defvar window (ceramic:make-window :url "https://www.google.com/"
                                    :width 800
                                    :height 600))

;; Show it
(ceramic:show-window window)
@end(code)

An 800-by-600 pixel browser window pointed at Google should pop up.

@end(section)

@begin(section)
@title(A web app)

With Ceramic, we can write a web application @l(ndash) using
@link[uri="http://clacklisp.org/"](Clack) @l(ndash) and create windows that use
it.

We'll be using @link[uri="https://github.com/eudoxia0/lucerne"](Lucerne), a web
framework built on Clack to write the web app, and Ceramic to use it as a
desktop app.

First, load Lucerne:

@code[lang=lisp](CL-USER> (ql:quickload :lucerne))

Then, tell Ceramic we're going to use the interactive mode:

@code[lang=lisp](CL-USER> (ceramic:interactive))

Now, let's create a basic application:

@begin[lang=lisp](code)
@begin(verb)
(in-package :cl-user)
(defpackage ceramic-webapp
  (:use :cl :lucerne)
  (:export :run))
(in-package :ceramic-webapp)
(annot:enable-annot-syntax)

;; Define an application
(defapp app)

;; Route requests to "/" to this function
@route app "/"
(defview hello ()
  (respond "Hello, world!"))

(defvar *window* nil)

(defvar *port* 8000)

(defun run ()
  (start app :port *port*)
  (setf *window*
        (ceramic:make-window :url (format nil "http://localhost:~D/" *port*)))
  (ceramic:show-window *window*))
@end(verb)
@end(code)

Calling @c(run), a browser window with the text "Hello, world!" should pop up.

@end(section)

@begin(section)
@title(Shipping)

@end(section)

@end(section)

@begin(section)
@title(Releasing)

@begin(section)
@title(Bundling)

Ceramic applications can be compiled to native executables. This is done through
the bundler, which compiles the app and its resources and external dependencies
into a bundle, which is just a .zip file.

A bundle looks like this:

@begin[lang=text](code)
my-app.zip/
  my-app ;; Executable
  electron/
    ... ;; The Electron code required to manage browser windows
  resources/
    ... ;; Application resources
@end(code)

@end(section)

@begin(section)
@title(Resources)

Every web application has external resources -- web assets like CSS and
JavaScript. And most non-trivial applications also keep data (game maps, CAD
files, etc.) in external files. In development, this data is usually stored
along with the source code. When releasing an application, that data has to be
bundled and released along with it.

Ceramic has tools for managing directories with resources: You map a symbol,
like @c(web-assets) or @c(game-data) to some directory relative to the
application (e.g. @c(assets/build/)). You access that directory using a function
that maps the symbol to a directory: in development, it just returns the
pathname to the original directory. When you release an app, all the resources
are copied over to the release, and the function returns the path the copied
resource directory in the release.

For instance, assuming an application named @c(my-app):

@begin[lang=lisp](code)
@begin(verb)
(use-package :ceramic.resource)

(define-resources :my-app () ;; Name of the system
  (web-assets #p"assets/build/")
  (landsat-images #p"data/landsat/")
  (icons #p"assets/icons/"))
@end(verb)
@end(code)

Then, to access the direcotry for the web assets, you use the
@c(resource-directory) function:

@begin[lang=lisp](code)
;;; In development

(resource-directory 'web-assets)
;; => /home/eudoxia/code/my-app/assets/build/

;;; In production

(resource-directory 'web-assets)
;; my-app/resources/web-assets/
@end(code)

To easily create a pathname relative to a resource directory, you have the
@c(resource) function:

@begin[lang=lisp](code)
;;; In development

(resource 'web-assets #p"css/style.css")
;; => /home/eudoxia/code/my-app/assets/build/css/style.css

;;; In production

(resource 'web-assets #p"css/style.css")
;; my-app/resources/web-assets/css/style.css
@end(code)

@begin(section)
@title(API)

@cl:with-package[name="ceramic.resource"](
@cl:doc(macro define-resources)
@cl:doc(function resource-directory)
@cl:doc(function resource)
)

@end(section)

@end(section)

@end(section)

@begin(section)
@title(API Reference)

@begin(section)
@title(Browser Windows)

The core API is available on the @c(ceramic) package.

@cl:with-package[name="ceramic"](
@cl:doc(class window)
@cl:doc(function make-window)
@cl:doc(method show-window (window window))
@cl:doc(method hide-window (window window))
@cl:doc(method close-window (window window))
@cl:doc(method destroy-window (window window))
)

@end(section)

@begin(section)
@title(Interactive Development)

@cl:with-package[name="ceramic"](
@cl:doc(function interactive)
)

@end(section)

@begin(section)
@title(Setup)

The @c(ceramic.setup) package exports a single function to get everything
prepared.

@cl:with-package[name="ceramic.setup"](
@cl:doc(function setup)
)

@end(section)

@begin(section)
@title(Files and Directories)

The basic filesystem-related operations ceramic performs are defined the
@c(ceramic.file) package.

@cl:with-package[name="ceramic.file"](
@cl:doc(variable *ceramic-directory*)
@cl:doc(function wipe-data)
)

@end(section)

@begin(section)
@title(Operating System Utilities)

These utilities are kept in the @c(ceramic.os) package.

@cl:with-package[name="ceramic.os"](
@cl:doc(variable *operating-system*)
@cl:doc(variable *architecture*)
)

@end(section)

@end(section)
